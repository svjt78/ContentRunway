"""DigitalDossier API Tool - Handle all API communication with digitaldossier.us."""

import os
import base64
import httpx
from typing import Any, Dict, List, Optional
import asyncio
from ..utils.publisher_logger import PublisherLogger


class DigitalDossierAPITool:
    """Tool for interacting with DigitalDossier.us API."""
    
    def __init__(self):
        self.logger = PublisherLogger()
        self.api_token = os.getenv('DIGITALDOSSIER_API_TOKEN')
        self.base_url = os.getenv('DIGITALDOSSIER_BASE_URL', 'http://localhost:3003')
        self.admin_email = os.getenv('DIGITALDOSSIER_ADMIN_EMAIL')
        self.admin_password = os.getenv('DIGITALDOSSIER_ADMIN_PASSWORD')
        
        # Validate configuration
        self._validate_config()
        
        # HTTP client with timeout
        self.client = httpx.AsyncClient(
            timeout=httpx.Timeout(30.0),
            headers={
                'Authorization': f'Bearer {self.api_token}'
                # Note: Content-Type will be set per request as needed
            }
        )
    
    def _validate_config(self):
        """Validate required environment variables."""
        if not self.api_token:
            raise ValueError("DIGITALDOSSIER_API_TOKEN environment variable is required")
        
        if not self.admin_email:
            raise ValueError("DIGITALDOSSIER_ADMIN_EMAIL environment variable is required")
        
        if not self.admin_password:
            raise ValueError("DIGITALDOSSIER_ADMIN_PASSWORD environment variable is required")
    
    async def fetch_genres(self) -> List[Dict[str, Any]]:
        """Fetch available genres from the API."""
        self.logger.log_operation_start("fetch_genres")
        
        try:
            response = await self.client.get(f"{self.base_url}/api/genres")
            response.raise_for_status()
            
            genres = response.json()
            self.logger.log_operation_success(
                "fetch_genres",
                {"genres_count": len(genres)},
                {"base_url": self.base_url}
            )
            
            return genres
            
        except httpx.HTTPError as e:
            error_msg = f"HTTP error fetching genres: {e}"
            self.logger.log_operation_failure("fetch_genres", error_msg)
            raise Exception(error_msg)
        except Exception as e:
            error_msg = f"Unexpected error fetching genres: {e}"
            self.logger.log_operation_failure("fetch_genres", error_msg)
            raise Exception(error_msg)
    
    async def upload_document(
        self,
        title: str,
        category: str,
        genre_id: int,
        cover_image: Optional[Dict[str, str]],
        pdf_file: Dict[str, str],
        summary: Optional[str] = None,
        content: Optional[str] = None,
        genre_metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """Upload document to DigitalDossier API."""
        
        operation_context = {
            "title": title,
            "category": category,
            "genre_id": genre_id,
            "has_cover_image": bool(cover_image),
            "has_pdf_file": bool(pdf_file),
            "has_genre_metadata": bool(genre_metadata)
        }
        
        self.logger.log_operation_start("upload_document", operation_context)
        
        try:
            # Prepare upload payload with correct field structure
            payload = {
                "title": title,
                "author": "Suvojit Dutta",
                "category": category,
                "genreId": genre_id,
                "pdfFile": pdf_file  # Fixed: Use 'pdfFile' instead of 'file'
            }
            
            # Add cover image only if present and valid
            if cover_image and cover_image.get('data'):
                # Ensure proper MIME type detection
                if not cover_image.get('mimeType'):
                    # Default to PNG if not specified
                    cover_image['mimeType'] = 'image/png'
                
                # Validate MIME type
                valid_mime_types = ['image/png', 'image/jpeg', 'image/jpg']
                if cover_image.get('mimeType') not in valid_mime_types:
                    self.logger.log_warning("upload_document", f"Invalid MIME type {cover_image.get('mimeType')}, defaulting to image/png")
                    cover_image['mimeType'] = 'image/png'
                
                payload["coverImage"] = cover_image
            
            # Add genre metadata for auto-creation if provided
            if genre_metadata:
                payload["genre"] = {
                    "id": genre_id,
                    "name": genre_metadata.get("selected_genre", "Auto-Generated Genre"),
                    "description": genre_metadata.get("reasoning", "Auto-generated genre based on content analysis"),
                    "isAutoGenerated": True,
                    "confidence": genre_metadata.get("confidence_score", 0.7),
                    "domain": genre_metadata.get("domain_focus", "General"),
                    "createdBy": "ContentRunway-LLM"
                }
            
            # Note: All uploads are PDF-only, no summary or content text needed
            
            # Log payload structure for debugging
            debug_payload = {
                "title": title,
                "category": category,
                "genreId": genre_id,
                "has_coverImage": bool(payload.get("coverImage")),
                "coverImage_mimeType": payload.get("coverImage", {}).get("mimeType"),
                "has_pdfFile": bool(payload.get("pdfFile")),
                "pdfFile_mimeType": payload.get("pdfFile", {}).get("mimeType"),
                "has_genre_metadata": bool(payload.get("genre")),
                "genre_name": payload.get("genre", {}).get("name") if payload.get("genre") else None
            }
            self.logger.log_info("upload_document", f"Upload payload structure: {debug_payload}")
            
            # Make API request with proper headers
            headers = {
                'Authorization': f'Bearer {self.api_token}',
                'Content-Type': 'application/json'
            }
            
            response = await self.client.post(
                f"{self.base_url}/api/upload/programmatic",
                json=payload,
                headers=headers
            )
            
            response.raise_for_status()
            result = response.json()
            
            self.logger.log_operation_success(
                "upload_document",
                result,
                operation_context
            )
            
            return result
            
        except httpx.HTTPStatusError as e:
            error_msg = f"HTTP {e.response.status_code} error uploading document: {e.response.text}"
            self.logger.log_operation_failure("upload_document", error_msg, operation_context)
            raise Exception(error_msg)
        except httpx.HTTPError as e:
            error_msg = f"HTTP error uploading document: {e}"
            self.logger.log_operation_failure("upload_document", error_msg, operation_context)
            raise Exception(error_msg)
        except Exception as e:
            error_msg = f"Unexpected error uploading document: {e}"
            self.logger.log_operation_failure("upload_document", error_msg, operation_context)
            raise Exception(error_msg)
    
    async def batch_upload_documents(
        self,
        documents: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """Upload multiple documents using batch API."""
        
        self.logger.log_operation_start(
            "batch_upload_documents",
            {"document_count": len(documents)}
        )
        
        try:
            # Prepare batch payload
            payload = {"documents": documents}
            
            response = await self.client.post(
                f"{self.base_url}/api/upload/programmatic/batch",
                json=payload
            )
            
            response.raise_for_status()
            result = response.json()
            
            self.logger.log_operation_success(
                "batch_upload_documents",
                {"results_count": len(result)},
                {"document_count": len(documents)}
            )
            
            return result
            
        except httpx.HTTPError as e:
            error_msg = f"HTTP error in batch upload: {e}"
            self.logger.log_operation_failure("batch_upload_documents", error_msg)
            raise Exception(error_msg)
        except Exception as e:
            error_msg = f"Unexpected error in batch upload: {e}"
            self.logger.log_operation_failure("batch_upload_documents", error_msg)
            raise Exception(error_msg)
    
    async def test_connection(self) -> Dict[str, Any]:
        """Test API connection and authentication."""
        self.logger.log_operation_start("test_connection")
        
        try:
            # Test with genres endpoint (lightweight)
            response = await self.client.get(f"{self.base_url}/api/genres")
            
            if response.status_code == 200:
                result = {
                    "status": "success",
                    "message": "Connection successful",
                    "base_url": self.base_url,
                    "genres_available": len(response.json())
                }
            else:
                result = {
                    "status": "error",
                    "message": f"Connection failed with status {response.status_code}",
                    "base_url": self.base_url
                }
            
            self.logger.log_operation_success("test_connection", result)
            return result
            
        except Exception as e:
            error_msg = f"Connection test failed: {e}"
            result = {
                "status": "error",
                "message": error_msg,
                "base_url": self.base_url
            }
            
            self.logger.log_operation_failure("test_connection", error_msg)
            return result
    
    def create_cover_image_object(self, image_data: bytes, filename: str = "cover.png") -> Dict[str, str]:
        """Create cover image object for API upload."""
        
        # Determine MIME type from filename extension
        import os
        file_ext = os.path.splitext(filename)[1].lower()
        
        mime_type_mapping = {
            '.png': 'image/png',
            '.jpg': 'image/jpeg',
            '.jpeg': 'image/jpeg'
        }
        
        mime_type = mime_type_mapping.get(file_ext, 'image/png')
        
        # Validate image data
        if not image_data:
            raise ValueError("Image data cannot be empty")
        
        # Ensure we have valid base64 data
        try:
            base64_data = base64.b64encode(image_data).decode('utf-8')
        except Exception as e:
            raise ValueError(f"Failed to encode image data to base64: {e}")
        
        return {
            "data": base64_data,
            "filename": filename,
            "mimeType": mime_type
        }
    
    def create_pdf_file_object(self, pdf_data: bytes, filename: str = "document.pdf") -> Dict[str, str]:
        """Create PDF file object for API upload."""
        return {
            "data": base64.b64encode(pdf_data).decode('utf-8'),
            "filename": filename,
            "mimeType": "application/pdf"
        }
    
    async def get_document(self, document_id: int) -> Dict[str, Any]:
        """Get document details by ID for verification."""
        self.logger.log_operation_start("get_document", {"document_id": document_id})
        
        try:
            response = await self.client.get(f"{self.base_url}/api/documents/{document_id}")
            
            if response.status_code == 200:
                result = {
                    "success": True,
                    "data": response.json()
                }
            else:
                result = {
                    "success": False,
                    "error": f"Document not found or access denied (HTTP {response.status_code})",
                    "status_code": response.status_code
                }
            
            self.logger.log_operation_success(
                "get_document",
                result,
                {"document_id": document_id}
            )
            
            return result
            
        except httpx.HTTPStatusError as e:
            error_msg = f"HTTP {e.response.status_code} error getting document: {e.response.text}"
            result = {
                "success": False,
                "error": error_msg,
                "status_code": e.response.status_code
            }
            self.logger.log_operation_failure("get_document", error_msg, {"document_id": document_id})
            return result
        except httpx.HTTPError as e:
            error_msg = f"HTTP error getting document: {e}"
            result = {
                "success": False,
                "error": error_msg
            }
            self.logger.log_operation_failure("get_document", error_msg, {"document_id": document_id})
            return result
        except Exception as e:
            error_msg = f"Unexpected error getting document: {e}"
            result = {
                "success": False,
                "error": error_msg
            }
            self.logger.log_operation_failure("get_document", error_msg, {"document_id": document_id})
            return result
    
    async def close(self):
        """Close HTTP client."""
        await self.client.aclose()
    
    async def __aenter__(self):
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()